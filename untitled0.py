# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

"""

#if GOOGLE_COLAB:
    from google.colab import drive, files
    drive.mount('/content/drive/')
    path = "/content/drive/My Drive/animals/"
training_data_dir = path + "training" # 10 000 * 2
validation_data = path + "validation" # 2 500 * 2
test_data_dir = path + "testing" # 12 500
DIR_TMP_DATA = '.'

import os
import matplotlib.pyplot as plt
from scipy.ndimage import imread
from scipy.misc import imsave
import numpy as np
import time

# %matplotlib inline

sample_img_path = os.path.join(training_data_dir,'antelope_10001'+'.jpg')
sample_img = plt.imread(sample_img_path)
plt.imshow(sample_img)
print ('Image have shape: {}'.format(sample_img.shape))

from keras.preprocessing import image
from keras.applications.imagenet_utils import preprocess_input
IMG_SHAPE = (150,150,3)

def loadAndResizeImage (img, w, h):
    '''
    loads the image in 'img' path and returns a PIL image of size (w,h)
    '''
    return image.load_img (img, target_size=(w,h))

# dog example resized
antelope_index = 10001
sample_img_path = os.path.join(training_data_dir,'antelope_'+str(antelope_index)+'.jpg')
sample_img = loadAndResizeImage (sample_img_path, IMG_SHAPE[0], IMG_SHAPE[1])
plt.imshow(sample_img)
print ('Antelope #'+str(antelope_index)+' as image:')

from PIL import Image

def getLabel (X):
    """
    Return the label for an element based on the filename: 
        dog -> 1 
        cat -> 0
    """
    if ('antelope' in X):
      return 0
    elif('bat' in X):
      return 0.1
    elif('beaver' in X):
      return 0.2
    elif('blue+whale' in X):
      return 0.3
    elif('bobcat' in X):
      return 0.4
    elif('buffalo' in X):
      return 0.5
    elif('chihuahua' in X):
      return 0.6
    elif('chimpanzee' in X):
      return 0.7
    elif('collie' in X):
      return 0.8
    elif('cow' in X):
        return 0.9
    elif('dalmatian' in X):
         return 0.12
    elif('deer' in X): 
         return 0.11
    else:
        return 100
    
def getLabels (X):
    """
    Returns an array that contains the label for each X
    """
    return np.array([getLabel(X[i]) for i in range(len(X))])

#def getLabelFromScore (score):
    """
    Returns the label based on the probability
    if score >= 0.5, return 'dog'
    else return 'cat'
    """
   # if (score >=0.5):
    #    return 'antelope'
   # else:
    #    return 'default'

def normalizedArrayFromImageInPath (image_path, img_shape):
    """
    returns an the image in 'image' path normalized in an np array
    """
    img = loadAndResizeImage (image_path, img_shape[0], img_shape[1])
    return image.img_to_array(img) / 255.

def loadResizeNormalizeImages (basepath, path_array, img_shape):
    """
    Loads the images from the path 
    and returns them in an array
    """
    images = np.empty ((len(path_array), img_shape[0], img_shape[1], img_shape[2]), dtype=np.float32)
    for i in range (len(path_array)):
        images[i] = normalizedArrayFromImageInPath (os.path.join(basepath,path_array[i]), img_shape)
    return images

import os
import numpy as np

train_imgs = os.listdir(training_data_dir)
validation_imgs=os.listdir(validation_data)
train_examples = 5760
train_x = train_imgs[:train_examples]
train_y = getLabels (train_x)
print(getLabels(train_x))
print ("Number of training examples = {}".format(len(train_x)))
print ("Number of training labels = {}".format(len(train_y)))

validation_examples = 475
validation_x = validation_imgs[:validation_examples]
validation_y = getLabels (validation_x)
#print(getLabels(validation_x))
print ("Number of validation examples = {}".format (len(validation_x)))
print ("Number of validation labels = {}".format(len(validation_y)))

img_train_x = loadResizeNormalizeImages (training_data_dir, train_x, IMG_SHAPE)
np.save (os.path.join(training_data_dir,'train_x'), img_train_x)
print (img_train_x.shape)
print ('Input X for training saved!')

img_validation_x = loadResizeNormalizeImages (validation_data, validation_x, IMG_SHAPE)
np.save (os.path.join(validation_data,'validation_x'), img_validation_x)
print (img_validation_x.shape)
print ('Input X for validation saved!')

print ('Checkpoint 1')

def dogsVsCatsProportion (labels):
    antelope = 0
    bat = 0
    beaver=0
    bluewhale=0
    bobcat=0
    buffalo=0
    chihuahua=0
    chimpanzee=0
    collie=0
    cow=0
    dalmatian=0
    deer=0
    
    for label in labels:
        if (label == 0):
          antelope = antelope + 1
        elif (label == 0.1):
          bat = bat + 1
        elif (label == 0.2):
          beaver = beaver + 1    
        elif (label == 0.3):
          bluewhale = bluewhale + 1            
        elif (label == 0.4):
          bobcat = bobcat + 1        
        elif (label == 0.5):
          buffalo = buffalo + 1
        elif (label == 0.6):
          chihuahua = chihuahua + 1
        elif (label == 0.7):
          chimpanzee = chimpanzee + 1
        elif (label == 0.8):
          collie = collie + 1    
        elif(label==0.9):
          cow = cow + 1
        elif(label==0.12):
           dalmatian=dalmatian+1
        else:
           deer=deer+1 
    
    
    antelope_percent = (antelope/len(labels))*100.0
    bat_percent = (bat/len(labels))*100
    beaver_percent=(beaver/len(labels))*100
    bluewhale_percent=(bluewhale/len(labels))*100
    bobcat_percent=(bobcat/len(labels))*100
    buffalo_percent=(buffalo/len(labels))*100
    chihuahua_percent=(chihuahua/len(labels))*100
    chimpanzee_percent=(chimpanzee/len(labels))*100
    cow_percent=(cow/len(labels))*100 
    dalmatian_percent=(dalmatian*100/len(labels))
    deer_percent=(deer*100/len(labels))
    print (antelope_percent)

    return antelope_percent, bat_percent,beaver_percent,bluewhale_percent,bobcat_percent,buffalo_percent,chihuahua_percent,chimpanzee_percent, cow_percent,dalmatian_percent,deer_percent

img_train_x = np.load (os.path.join(training_data_dir,'train_x')+'.npy')
img_validation_x = np.load (os.path.join(validation_data,'validation_x')+'.npy')

print ('Input X train and validation loaded!')
antelope, bats,beaver,bluewhale,bobcat,buffalo,chihuahua,chimpanzee, cow,dalmatian,deer = dogsVsCatsProportion (train_y)
print ("--> Training set: antelopes represent "+str(antelope)+"% of the total")
print ("    bats represent "+str(bats))
print ("    beaver represent "+str(beaver))
print ("    bluewhale represent "+str(bluewhale))
print ("    bobcat represent "+str(bobcat))
print ("    buffalo represent "+str(buffalo))
print ("    chihuahua represent "+str(chihuahua))
print ("    chimpanzee represent "+str(chimpanzee))
print ("    cow represent "+str(cow))
print(" dalmation represent"+ str(dalmatian))
print("deer represent" +str(deer))
antelope, bat,beaver,bluewhale,bobcat,buffalo,chihuahua,chimpanzee, cow, dalmatian,deer = dogsVsCatsProportion (validation_y)
print ("--> Validation set: antelopes represent "+str(antelope)+"% of the total")
print ("    bats represent "+str(bat))
print ("    beaver represent "+str(beaver))
print ("    bluewhale represent "+str(bluewhale))
print ("    bobcat represent "+str(bobcat))
print ("    buffalo represent "+str(buffalo))
print ("    chihuahua represent "+str(chihuahua))
print ("    chimpanzee represent "+str(chimpanzee))
print ("    cow represent "+str(cow))
print(" dalmatian represent"+ str(dalmatian))
print("deer represent" +str(deer))

from keras.applications.inception_v3 import InceptionV3
from keras.preprocessing import image
from keras.models import Model
from keras.layers import Dense, GlobalAveragePooling2D, Dropout
from keras import backend as K

# create the base pre-trained model
base_model = InceptionV3(weights='imagenet', include_top=False)

# add a global spatial average pooling layer
x = base_model.output
x = GlobalAveragePooling2D()(x)
# let's add a fully-connected layer
x = Dense(1024, activation='relu')(x)
# add dropout
x = Dropout (0.5)(x)
# one fully connected layer more
x = Dense(256, activation='relu')(x)
# add dropout
x = Dropout (0.5)(x)
# one fully connected layer more
x = Dense(32, activation='relu')(x)
# and a logistic layer --
predictions = Dense(1, activation='sigmoid')(x)

# this is the model we will train
model = Model(inputs=base_model.input, outputs=predictions)

# first: train only the top layers (which were randomly initialized)
# i.e. freeze all convolutional InceptionV3 layers
for layer in base_model.layers:
    layer.trainable = False

# compile the model (should be done *after* setting layers to non-trainable)
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

from keras import models
from keras.layers import Dense, Dropout
from keras.utils import to_categorical
from keras.datasets import mnist
from keras.utils.vis_utils import model_to_dot
from IPython.display import SVG

NUM_ROWS = 28
NUM_COLS = 28
NUM_CLASSES = 10
BATCH_SIZE = 128
EPOCHS = 10


model = models.Sequential()
model.add(Dense(512, activation='relu', input_shape=(5760,150,150,3)))
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.25))
model.add(Dense(10, activation='softmax'))

# Compile model
model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# Train model
#model.fit(img_train_x, train_y,
 #         epochs=EPOCHS,
  #        validation_data=(img_test_x, test_y))

  model.fit (x=img_train_x, y=train_y, 
           batch_size=20, epochs=6, 
           validation_data=(img_validation_x, validation_y))
score = model.evaluate(img_test_x, test_y)
print('Test loss:', score[0])
print('Test accuracy:', score[1])

model.fit (x=img_train_x, y=train_y, 
           batch_size=20, epochs=6, 
           validation_data=(img_validation_x, validation_y))

print ('Saving the model...')
model.save(os.path.join(training_data_dir,'model.h5'))
print ('Model saved! Filename: {}'.format (os.path.join(training_data_dir,'model.h5')))
print ('Checkpoint 2')

test_examples = 2640
test_imgs = os.listdir(test_data_dir)
test_x = test_imgs[:test_examples]

test_y = getLabels (test_x)

print(test_y)
print ("Number of test dev examples = "+str(len(test_x)))
print ("Number of test dev labels = "+str(len(test_y)))

print ("First element of test dev set "+test_x[0])
print ("Label of first element of test dev set = "+str(test_y[0]))

img_test_x = loadResizeNormalizeImages (test_data_dir, test_x, IMG_SHAPE)
print (img_test_x.shape)

#print ('Saving test set...')
#np.save (os.path.join(DIR_TMP_DATA,'test_x'), img_test_x)
#print ('Input X for test saved!')
#print ('Checkpoint 3')

print ('Saving test set...')
np.save (os.path.join(DIR_TMP_DATA,'test_x'), img_test_x)
print ('Input X for test saved!')
print ('Checkpoint 3')

img_test_x = np.load (os.path.join(DIR_TMP_DATA,'test_x')+'.npy')
print ('Input X for evaluation loaded!')

# check the proportion dogs vs cats
print ('Input X train and validation loaded!')
antelope, bats,beaver,bluewhale,bobcat,buffalo,chihuahua,chimpanzee, cow,dalmation,deer = dogsVsCatsProportion (train_y)
print ("--> Training set: antelopes represent "+str(antelope)+"% of the total")
print ("    bats represent "+str(bats))
print ("    beaver represent "+str(beaver))
print ("    bluewhale represent "+str(bluewhale))
print ("    bobcat represent "+str(bobcat))
print ("    buffalo represent "+str(buffalo))
print ("    chihuahua represent "+str(chihuahua))
print ("    chimpanzee represent "+str(chimpanzee))
print ("    cow represent "+str(cow))
print ("    dalmation represent "+str(dalmation))
print ("    deer represent "+str(deer))

preds = model.evaluate (x=img_test_x, y=test_y, batch_size=20)
print()
print ("Loss = " + str(preds[0]))
print ("Test Accuracy = " + str(preds[1]))

def predictFromPath (img_path, img_size=(150,150)):
    img = normalizedArrayFromImageInPath (img_path, img_size)
    return predictFromImg (img)

def predictFromImg (img):
    x = np.expand_dims(img, axis=0)
    return model.predict(x)[0][0]

img_path = test_data_dir+'/cow_11076.jpg'
display_img = image.load_img(img_path)
start = time.time()
score = predictFromPath (img_path)
end = time.time()
print("Prediction took {:.3f} seconds".format (end - start))
print(score)
plt.imshow(display_img)

